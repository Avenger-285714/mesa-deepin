From 5c037a0e35164eae9ba0dcd1252e8d20220c8b58 Mon Sep 17 00:00:00 2001
From: Icenowy Zheng <uwu@icenowy.me>
Date: Sat, 20 Sep 2025 22:52:30 +0800
Subject: [PATCH] gallivm: orcjit: put object cache under the protect of
 lookup_mutex

Different threads calling gallivm share the same LPJIT (and the
underlying LLJIT) instance, which could be only bound to a single cache
object at the same time.

Pass the object cache when looking up the symbol and put it under the
protect of lookup_mutex to prevent accessing wrong cache.

This seems to fix some MissingSymbolDefinitions error when running
Plasma Shell with llvmpipe on RISC-V.

Signed-off-by: Icenowy Zheng <uwu@icenowy.me>
---
 .../auxiliary/gallivm/lp_bld_init_orc.cpp     | 24 ++++++++++---------
 1 file changed, 13 insertions(+), 11 deletions(-)

diff --git a/src/gallium/auxiliary/gallivm/lp_bld_init_orc.cpp b/src/gallium/auxiliary/gallivm/lp_bld_init_orc.cpp
index 3d2b8cf81bc0c..6651ea439da86 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_init_orc.cpp
+++ b/src/gallium/auxiliary/gallivm/lp_bld_init_orc.cpp
@@ -234,13 +234,18 @@ public:
 
    static void *lookup_in_jd(
          const char *func_name,
-         LLVMOrcJITDylibRef jd) {
+         LLVMOrcJITDylibRef jd,
+         llvm::ObjectCache *objcache) {
       using llvm::orc::JITDylib;
       using llvm::JITEvaluatedSymbol;
       using llvm::orc::ExecutorAddr;
       JITDylib* JD = ::unwrap(jd);
       LPJit* jit = get_instance();
+      auto &ircl = jit->lljit->getIRCompileLayer();
+      auto &irc = ircl.getCompiler();
+      auto &sc = dynamic_cast<llvm::orc::SimpleCompiler &>(irc);
       jit->lookup_mutex.lock();
+      sc.setObjectCache(objcache);
       auto func = ExitOnErr(jit->lljit->lookup(*JD, func_name));
       jit->lookup_mutex.unlock();
 #if LLVM_VERSION_MAJOR >= 15
@@ -257,12 +262,6 @@ public:
       ExitOnErr(es.removeJITDylib(* ::unwrap(jd)));
    }
 
-   static void set_object_cache(llvm::ObjectCache *objcache) {
-      auto &ircl = LPJit::get_instance()->lljit->getIRCompileLayer();
-      auto &irc = ircl.getCompiler();
-      auto &sc = dynamic_cast<llvm::orc::SimpleCompiler &>(irc);
-      sc.setObjectCache(objcache);
-   }
    LLVMTargetMachineRef tm;
 
 private:
@@ -622,7 +621,6 @@ gallivm_free_ir(struct gallivm_state *gallivm)
    gallivm->_ts_context=NULL;
    gallivm->cache=NULL;
    LPJit::deregister_gallivm_state(gallivm);
-   LPJit::set_object_cache(NULL);
 }
 
 void
@@ -657,8 +655,6 @@ gallivm_compile_module(struct gallivm_state *gallivm)
          LPObjectCacheORC *objcache = new LPObjectCacheORC(gallivm->cache);
          gallivm->cache->jit_obj_cache = (void *)objcache;
       }
-      auto *objcache = (LPObjectCacheORC *)gallivm->cache->jit_obj_cache;
-      LPJit::set_object_cache(objcache);
    }
    /* defer compilation till first lookup by gallivm_jit_function */
 }
@@ -667,8 +663,14 @@ func_pointer
 gallivm_jit_function(struct gallivm_state *gallivm,
                      LLVMValueRef func, const char *func_name)
 {
+   LPObjectCacheORC *objcache = NULL;
+   if (gallivm->cache) {
+      assert(gallivm->cache->jit_obj_cache);
+      objcache = (LPObjectCacheORC *)gallivm->cache->jit_obj_cache;
+   }
+
    return pointer_to_func(
-      LPJit::lookup_in_jd(func_name, gallivm->_per_module_jd));
+      LPJit::lookup_in_jd(func_name, gallivm->_per_module_jd, objcache));
 }
 
 void
-- 
GitLab

